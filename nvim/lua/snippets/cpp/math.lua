local ls = require("luasnip")
local s = ls.snippet
local t = ls.text_node

ls.add_snippets("cpp", {

  s("numth", {
    t({
      "// ================= NUMBER THEORY TEMPLATE =================",
      "",
      "struct NumberTheory {",
      "    int N;",
      "    vector<int> primes;",
      "    vector<int> spf;",
      "    vector<int> phi;",
      "    vector<int> mu;",
      "    vector<long long> sigma;",
      "    vector<int> dcnt;",
      "    vector<bool> is_prime;",
      "",
      "    NumberTheory(int n = 0) {",
      "        if (n > 0) init(n);",
      "    }",
      "",
      "    void init(int n) {",
      "        N = n;",
      "        primes.clear();",
      "        spf.assign(N + 1, 0);",
      "        phi.assign(N + 1, 0);",
      "        mu.assign(N + 1, 0);",
      "        sigma.assign(N + 1, 0);",
      "        dcnt.assign(N + 1, 0);",
      "        is_prime.assign(N + 1, true);",
      "",
      "        is_prime[0] = is_prime[1] = false;",
      "        phi[1] = 1;",
      "        mu[1] = 1;",
      "        sigma[1] = 1;",
      "        dcnt[1] = 1;",
      "",
      "        for (int i = 2; i <= N; i++) {",
      "            if (spf[i] == 0) {",
      "                spf[i] = i;",
      "                primes.push_back(i);",
      "                phi[i] = i - 1;",
      "                mu[i] = -1;",
      "                sigma[i] = 1 + i;",
      "                dcnt[i] = 2;",
      "            }",
      "",
      "            for (int p : primes) {",
      "                if (p > spf[i] || i * 1LL * p > N) break;",
      "",
      "                int x = i * p;",
      "                spf[x] = p;",
      "                is_prime[x] = false;",
      "",
      "                if (i % p == 0) {",
      "                    phi[x] = phi[i] * p;",
      "                    mu[x] = 0;",
      "",
      "                    int cnt = 0;",
      "                    int tmp = i;",
      "                    while (tmp % p == 0) {",
      "                        tmp /= p;",
      "                        cnt++;",
      "                    }",
      "",
      "                    dcnt[x] = dcnt[i] / (cnt + 1) * (cnt + 2);",
      "                    sigma[x] = sigma[i] + (long long)pow(p, cnt + 1);",
      "",
      "                    break;",
      "                } else {",
      "                    phi[x] = phi[i] * (p - 1);",
      "                    mu[x] = -mu[i];",
      "                    dcnt[x] = dcnt[i] * 2;",
      "                    sigma[x] = sigma[i] * (1 + p);",
      "                }",
      "            }",
      "        }",
      "    }",
      "};",
      "",
      "// =========================================================",
    }),
  }),
})
