local ls = require("luasnip")
local s = ls.snippet
local t = ls.text_node

ls.add_snippets("cpp", {

  s("modall", {
    t({
      "// ================= MODULAR ARITHMETIC TEMPLATE =================",
      "",
      "static const int MOD = 1000000007;",
      "",
      "struct Mint {",
      "    int v;",
      "",
      "    Mint(long long _v = 0) {",
      "        v = int((_v % MOD + MOD) % MOD);",
      "    }",
      "",
      "    Mint& operator+=(const Mint &o) {",
      "        v += o.v;",
      "        if (v >= MOD) v -= MOD;",
      "        return *this;",
      "    }",
      "",
      "    Mint& operator-=(const Mint &o) {",
      "        v -= o.v;",
      "        if (v < 0) v += MOD;",
      "        return *this;",
      "    }",
      "",
      "    Mint& operator*=(const Mint &o) {",
      "        v = int((long long)v * o.v % MOD);",
      "        return *this;",
      "    }",
      "",
      "    friend Mint operator+(Mint a, const Mint &b) { return a += b; }",
      "    friend Mint operator-(Mint a, const Mint &b) { return a -= b; }",
      "    friend Mint operator*(Mint a, const Mint &b) { return a *= b; }",
      "",
      "    static Mint pow(Mint a, long long e) {",
      "        Mint r = 1;",
      "        while (e) {",
      "            if (e & 1) r *= a;",
      "            a *= a;",
      "            e >>= 1;",
      "        }",
      "        return r;",
      "    }",
      "",
      "    static Mint inv(Mint a) {",
      "        return pow(a, MOD - 2);",
      "    }",
      "",
      "    Mint& operator/=(const Mint &o) {",
      "        return (*this) *= inv(o);",
      "    }",
      "",
      "    friend Mint operator/(Mint a, const Mint &b) { return a /= b; }",
      "",
      "    friend ostream& operator<<(ostream &os, const Mint &m) {",
      "        return os << m.v;",
      "    }",
      "};",
      "",
      "struct Combinatorics {",
      "    vector<Mint> fact, invfact;",
      "",
      "    Combinatorics(int n = 0) {",
      "        if (n > 0) init(n);",
      "    }",
      "",
      "    void init(int n) {",
      "        int cur = fact.size();",
      "        if (cur > n) return;",
      "",
      "        fact.resize(n + 1);",
      "        invfact.resize(n + 1);",
      "",
      "        if (cur == 0) {",
      "            fact[0] = 1;",
      "            cur = 1;",
      "        }",
      "",
      "        for (int i = cur; i <= n; i++)",
      "            fact[i] = fact[i - 1] * i;",
      "",
      "        invfact[n] = Mint::inv(fact[n]);",
      "        for (int i = n; i > cur; i--)",
      "            invfact[i - 1] = invfact[i] * i;",
      "    }",
      "",
      "    Mint C(int n, int r) {",
      "        if (r < 0 || r > n) return 0;",
      "        init(n);",
      "        return fact[n] * invfact[r] * invfact[n - r];",
      "    }",
      "",
      "    Mint P(int n, int r) {",
      "        if (r < 0 || r > n) return 0;",
      "        init(n);",
      "        return fact[n] * invfact[n - r];",
      "    }",
      "};",
      "",
      "// ===============================================================",
    }),
  }),
})
