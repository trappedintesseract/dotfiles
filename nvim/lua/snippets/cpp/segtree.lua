local ls = require("luasnip")
local s = ls.snippet
local t = ls.text_node
local i = ls.insert_node

ls.add_snippets("cpp", {

  s("seg", {
    t({
      "// ================== GENERIC LAZY SEGMENT TREE ==================",
      "",
      "struct SegTree {",
      "    // ----------- CHANGEABLE PART 1 -----------",
      "    struct Node {",
      "        ",
    }),
    i(1, "// define what a segment stores"),
    t({
      "",
      "    };",
      "",
      "    struct Lazy {",
      "        ",
    }),
    i(2, "// define what lazy operation stores"),
    t({
      "",
      "    };",
      "    // ----------------------------------------",
      "",
      "    int n;",
      "    vector<Node> st;",
      "    vector<Lazy> lazy;",
      "",
      "    SegTree(int n) : n(n) {",
      "        st.resize(4 * n);",
      "        lazy.resize(4 * n);",
      "    }",
      "",
      "    // ----------- CHANGEABLE PART 2 -----------",
      "    Node neutral_node() {",
      "        ",
    }),
    i(3, "// identity element for merge"),
    t({
      "",
      "    }",
      "",
      "    Lazy neutral_lazy() {",
      "        ",
    }),
    i(4, "// identity element for lazy"),
    t({
      "",
      "    }",
      "",
      "    Node merge(const Node &L, const Node &R) {",
      "        ",
    }),
    i(5, "// combine children -> parent"),
    t({
      "",
      "    }",
      "",
      "    void apply(int v, int l, int r, const Lazy &lz) {",
      "        ",
    }),
    i(6, "// apply lazy to node"),
    t({
      "",
      "    }",
      "",
      "    void push(int v, int l, int r) {",
      "        ",
    }),
    i(7, "// push lazy to children"),
    t({
      "",
      "    }",
      "    // ----------------------------------------",
      "",
      "    // ================ ENGINE =================",
      "",
      "    void build(int v, int l, int r) {",
      "        lazy[v] = neutral_lazy();",
      "        if (l == r) {",
      "            ",
    }),
    i(8, "// initialize leaf"),
    t({
      "",
      "            return;",
      "        }",
      "        int m = (l + r) >> 1;",
      "        build(v<<1, l, m);",
      "        build(v<<1|1, m+1, r);",
      "        st[v] = merge(st[v<<1], st[v<<1|1]);",
      "    }",
      "",
      "    void update(int v, int l, int r, int ql, int qr, const Lazy &lz) {",
      "        if (qr < l || r < ql) return;",
      "        if (ql <= l && r <= qr) {",
      "            apply(v, l, r, lz);",
      "            return;",
      "        }",
      "        push(v, l, r);",
      "        int m = (l + r) >> 1;",
      "        update(v<<1, l, m, ql, qr, lz);",
      "        update(v<<1|1, m+1, r, ql, qr, lz);",
      "        st[v] = merge(st[v<<1], st[v<<1|1]);",
      "    }",
      "",
      "    Node query(int v, int l, int r, int ql, int qr) {",
      "        if (qr < l || r < ql) return neutral_node();",
      "        if (ql <= l && r <= qr) return st[v];",
      "        push(v, l, r);",
      "        int m = (l + r) >> 1;",
      "        return merge(",
      "            query(v<<1, l, m, ql, qr),",
      "            query(v<<1|1, m+1, r, ql, qr)",
      "        );",
      "    }",
      "",
      "    // OPTIONAL PATTERNS (ENABLE WHEN NEEDED)",
      "",
      "    // find first index >= ql satisfying condition",
      "    int find_first(int v, int l, int r, int ql) {",
      "        ",
    }),
    i(9, "// guided descent logic"),
    t({
      "",
      "    }",
      "",
      "    // find k-th element logic",
      "    int kth(int v, int l, int r, int k) {",
      "        ",
    }),
    i(10, "// guided descent logic"),
    t({
      "",
      "    }",
      "};",
      "// ==============================================================",
    }),
  }),
})
